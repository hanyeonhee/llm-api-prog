prompt	completion
JPEG는 손실 데이터 압축 알고리즘을 사용하는데, 이는 JPEG 파일에서 복구된 이미지가 원본 이미지와 정확히 동일하지 않다는 것을 의미한다; 일부 정보가 손실되었다.	JPEG는 손실 데이터 압축 알고리즘을 사용한다. 따라서 JPEG 파일을 복원한 이미지는 일부 정보를 빠뜨리므로 원본 이미지와 똑같지 않다.
스파크는 스칼라(Scala)로 작성되었는데, 이는 강력한 함수형 특성을 가지고 있으며 JVM(Java Virtual Machin, 자바 가상 머신)으로 컴파일된다.	스파크는 기능적인 측면이 강하고 자바 가상 머신(JVM)용으로 컴파일되는 언어인 스칼라(Scala)로 작성되었다.
이 설문조사 결과는 청소년 언어 개선책을 시급히 마련해야 한다는 점을 말해 주고 있다.	청소년 언어 개선책을 시급히 마련해야 한다는 점을 이 설문조사 결과에서 알 수 있다.
애완동물은 많은 보살핌과 관심을 필요로 한다.	애완동물에게는 많은 보살핌과 관심이 필요하다.
보들레르의 작품에 들어 있는 알레고리적인 것을 연구할 때 바로크적 요소에 너무 주목한 나머지 중세적 요소를 간과하는 것은 오류일 것이다.	보들레르 작품의 알레고리적인 것을 연구할 때 바로크적 요소에 너무 주목한 나머지 중세적 요소를 간과함은 오류다.
사유재산이 우리를 너무나 어리석고 무기력하게 만들었기 때문에 어떤 사물은 오직 그것을 소유할 때만 비로소, 그러니까 우리를 위한 자본으로 존재할 때 또는 우리에 의해 사용될 때라야 비로소 우리 것이 된다.	사유재산이 우리를 너무나 어리석고 무기력하게 만들었기에, 어떤 사물은 오직 그것을 소유할 때만, 즉 우리를 위한 자본으로 존재할 때 또는 우리가 사용할 때라야 우리 것이 된다.
조회할 내용이 없는 것으로 판단합니다.	조회할 내용이 없다고 판단합니다.
수십 년에 걸쳐 분리뇌를 연구한 결과, 두 뇌가 전문적으로 담당하는 기능을 밝혀냈을 뿐 아니라 각 뇌 안에서 이루어지는 전문화 과정에 대해 통찰력도 제공했다.	수십 년에 걸친 분리뇌 연구로, 양쪽 뇌는 각각 분화된 기능을 담당한다는 사실이 밝혀졌을 뿐 아니라 각각의 뇌에서 일어나는 분화에 대해서도 더 깊이 이해하게 되었다.
애착은 물건, 사람, 활동, 견해나 느낌에 대한 정신과 정서(일반적인 강박)의 연결이며 이 연결이 독특하고 영구적인 방식으로 쾌락, 보안, 자아실현을 제공할 것이라는 비이성 논리에서 유래되었다.	애착은 사물, 사람, 활동, 개념 혹은 감정에 대한 정신적, 정서적(일반적으로 강박적) 유대로, 이러한 유대를 통해 고유하고도 영구적인 방식으로 기쁨과 안정을 얻고 자아실현을 이룰 수 있을 것이라는 비이성적인 믿음에서 비롯되었다.
그들은 훌륭한 교사란 자신만이 아이들을 훈육할 수 있고 다른 사람들은 할 수 없다고 생각한다.	그들은 그것이 자신이 훌륭한 교사임을 보여주는 증거라고 생각한다. 자신은 아이들을 잘 통제하는데 다른 사람은 그러지 못한다면서.
실무에서는 데이터 출력 후에 표기 흔들림의 통일 등의 작업이 필요할 수 있습니다.	실무에서는 데이터 출력 후 표기법 통일 등의 작업이 필요합니다.
설정된 토큰 수가 ChatGPT에 제공하는 문장 양의 상한값입니다.	설정된 토큰 수가 ChatGPT에 주는 문장량의 상한이 됩니다.
이러한 새로운 시도가 학생들의 수학 성취도 향상에 성공적일지는 확인되어져야 한다.	이러한 새로운 방법으로 학생의 수학 성적을 향상시킬 수 있을지는 아직 검증이 필요하다.
제일 긴 그 다리가 폭격에 의해 아깝게 끊어진 뒤로는	제일 긴 그 다리가 폭격으로 아깝게 끊어진 뒤로는
내 시계에 의하면 두 시이다.	내 시계로는 두 시이다.
그에게는 정직성이 부족합니다.	그는 정직하지 않습니다.
앞으로 정치에 냉소적이거나 무관심한 것이 자랑인 것처럼 여기며 살지는 않을 것이라는 결심을 했죠.	앞으로 정치에 냉소적이거나 무관심한 것을 자랑처럼 여기며 살지 않겠다고 결심했죠.
타입스크립트 지원 여부도	타입스크립트를 지원하는지도
코딩을 통한 학습은 딥러닝을 배우고자 하는 사람은 꼭 해보고 싶어하지만 대부분 중도에 포기하게 된다. 딥러닝 프로젝트를 수행하기 위해 문서를 읽고 내게 필요한 유용한 정보를 찾아내는 일은 번거롭다. 이 과정에서 너무 많은 학생들이 좌절하는 것을 보았다. 초보자가 전문가가 되기 위해 사용할 수 있는 자원은 무한히 많다. 그렇지만 초보자가 개념 중심의 교육과정과 코딩 지식이 필요한 수많은 교육 프로그램 사이에서 균형을 유지하려고 노력하는 동안 배우기를 포기하기 쉽다.	코딩을 통한 학습은 딥러닝을 배우고자 하는 사람은 꼭 해보고 싶어하지만 대부분 중도에 포기한다. 딥러닝 프로젝트를 수행하기 위해 문서를 읽고 내게 필요한 유용한 정보를 찾아내는 일은 번거롭다. 이 과정에서 너무 많은 학생들이 좌절하는 것을 보았다. 초보자가 전문가로 성장하는 데 활용할 수 있는 자원은 무한히 많다. 그렇지만 초보자가 개념 중심의 교육과정과 코딩 지식이 필요한 수많은 교육 프로그램 사이에서 균형을 유지하려고 애쓰다가 배움을 포기하기 쉽다.
파이토치를 개괄적으로 훑어보는 것으로 시작해 이미지 분류를 위한 합성곱 신경망(convolutional neural network, CNN)을 살펴본다. 또한 트랜스포머(Transformers)와 함께 순환신경망(recurrent neural network, RNN) 아키텍처를 살펴보고 감성 분석하는 데 이를 사용한다. 계속해서, 딥러닝을 음악, 텍스트, 이미지를 생성 모델을 사용해 생성하는 등 다양한 영역에 적용할 것이다. 그런 다음 생성적 적대 신경망(generative adversarial networks, GAN)의 세계를 깊이 탐구하고 파이토치에서 심층 강화 학습 모델을 만들고 훈련시키고 딥러닝 모델을 해석한다. 모델을 만드는 방법뿐 아니라 전문가 팁과 기술을 사용해 파이토치 모델을 운영에 배포하는 방법도 배운다. 마지막으로 분산 시스템에서 대규모 모델을 효율적으로 훈련시키는 방법을 완벽히 이해하고, 어떤 신경망 아키텍처를 사용할지 AutoML로 효과적으로 찾아내고 파이토치와 fast.ai를 사용해 모델을 빠르게 프로토타이핑한다.	파이토치를 개괄적으로 훑어보는 것으로 시작해 이미지 분류를 위한 합성곱 신경망을 살펴본다. 또한 트랜스포머와 함께 RNN 아키텍처를 살펴보고 감성 분석에 활용한다. 계속해서, 생성 모델을 사용해 음악, 텍스트, 이미지를 생성하는 등 다양한 곳에 딥러닝을 적용할 것이다. 그런 다음 GAN의 세계를 깊이 탐구하고 파이토치에서 심층 강화학습 모델을 만들고 훈련시키고 딥러닝 모델을 해석한다. 모델을 만드는 방법뿐 아니라 파이토치 모델을 운영에 배포하는 기술과 팁을 배운다. 마지막으로 분산 시스템에서 대규모 모델을 효율적으로 훈련시키는 방법을 소개하고, 어떤 신경망 아키텍처를 사용할지를 AutoML로 효과적으로 찾아내고 파이토치와 fast.ai로 모델을 빠르게 프로토타이핑한다.
utils.data 모듈에서 토치는 자체적으로 데이터셋과 DatasetLoader 클래스를 제공하는데, 추상적이면서도 유연하게 구현되어 상당히 사용하기 쉽다. 기본적으로 이 클래스는 텐서에 기타 다른 연산을 수행하고 반복하는 직관적이며 유용한 방법을 제공한다. 이 연산을 사용하면 최적화된 텐서 계산으로 높은 성능을 보장할 수 있으며, 또한 오류가 발생해도 안전한 데이터 I/O도 가질 수 있다. 예를 들어, torch.utils.data.DataLoader를 다음과 같이 사용한다고 하자.	토치에서 utils.data 모듈을 통해 제공하는 자체 데이터셋과 DatasetLoader 클래스들은 추상적이면서도 유연하게 구현되어 상당히 사용하기 쉽다. 이 클래스들을 이용하면 직관적인 방법으로 텐서에 대한 이터레이션 및 기타 연산을 수행할 수 있고, 최적화된 텐서 계산으로 높은 성능이 보장되며, 데이터 입출력 오류도 피할 수 있다. 예를 들어, torch.utils.data.DataLoader를 다음과 같이 사용한다고 하자.
합성곱 계층의 출력의 채널 개수는 일반적으로 입력 채널 개수와 같거나 크다. 첫 번째 합성곱 계층은 1채널 데이터를 취하고 16채널을 출력한다. 이는 기본적으로 이 계층이 입력 이미지로부터 16가지의 서로 다른 정보를 탐지한다는 것을 뜻한다. 이 각각의 채널을 특징 맵(feature map)이라고 하고 각각에는 그에 해당하는 특징을 추출하는 전용 커널이 있다.	합성곱 계층의 출력 채널 수는 일반적으로 입력 채널 수와 같거나 크다. 첫 번째 합성곱 계층은 1채널 데이터를 취해 16채널을 출력한다. 즉, 이 계층은 입력 이미지로부터 16가지 정보를 탐지한다. 각 채널을 특징 맵(feature map)이라고 하고 각각에는 특징을 추출하는 전용 커널이 있다.
대부분의 지도 머신러닝 모델은 일대일 관계를 모델링하지만 RNN은 다음 유형의 입출력 관계를 모델링할 수 있다.	지도 머신러닝 모델은 대체로 일대일 관계를 모델링하지만 RNN은 다음 유형의 입출력 관계를 모델링할 수 있다.
이 장에서는 순환 신경망 아키텍처를 광범위하게 살펴봤다. 먼저 일대다, 다대다 등 다양한 RNN 유형에 대해 알아봤다. 그런 다음 RNN 아키텍처의 역사와 진화 과정을 배웠다. 이 때 단순한 형태의 RNN, LSTM, GRU부터 양방향, 다차원, 적층형 모델까지 살펴봤다. 또한 이 각각의 아키텍처가 어떻게 생겼는지 그리고 해당 아키텍처에서 새로운 점은 무엇인지 따져봤다.	이 장에서는 순환 신경망 아키텍처를 광범위하게 살펴봤다. 먼저 일대다, 다대다 등 다양한 RNN 유형을 알아봤다. 그런 다음 RNN 아키텍처의 역사와 진화 과정을 배웠다. 이때 단순한 형태의 RNN, LSTM, GRU부터 양방향, 다차원, 적층형 모델까지 살펴봤다. 각 아키텍처가 어떻게 생겼는지, 해당 아키텍처에서 새로운 점은 무엇인지도 따져봤다.
먼저 알아야 할 것은 이 모델은 인코더-디코더 기반의 아키텍처로 위 그림에서 왼쪽 보라색은 **인코더**이고 오른쪽 주황색은 **디코더**에 해당한다. 아키텍처가 깊어질수록 인코더와 디코더는 여러 번 이어 붙일 수 있다. 이 예제에서는 두 개의 인코더와 하나의 디코더로 구성된다. 이 인코더-디코더 설정은 근본적으로 인코더가 시퀀스를 입력으로 가져와서 입력 시퀀스에 있는 단어 수만큼의 임베딩을 생성함(즉, 단어 하나 당 하나의 임베딩)을 뜻한다. 이 임베딩은 지금까지 모델에서 만들어진 예측과 함께 디코더에 제공된다.	이 모델은 인코더-디코더 기반의 아키텍처로 위 그림에서 왼쪽 보라색은 **인코더**이고 오른쪽 주황색은 **디코더**에 해당한다. 아키텍처가 깊어질수록 인코더와 디코더는 여러 번 이어 붙일 수 있다. 이 예제에서는 두 개의 인코더와 하나의 디코더로 구성된다. 이 인코더-디코더 설정은 인코더가 시퀀스를 입력으로 가져와서 입력 시퀀스에 있는 단어 수만큼의 임베딩을 생성함(단어 하나 당 하나의 임베딩)을 뜻한다. 이 임베딩은 지금까지 모델에서 만들어진 예측과 함께 디코더에 제공된다.
2. 다음으로 볼 함수는 에피소드 마지막에 어떤 일이 일어나는지 정의한다. 현재 에피소드에서 얻은 전체 보상이 지금까지 중 최고라면 CNN 모델 가중치를 저장하고 보상 값을 출력한다.	2. 다음으로 볼 함수는 각 에피소드의 끝에서 어떤 일이 일어나는지 정의한다. 현재 에피소드에서 얻은 전체 보상이 지금까지 중 최고라면 CNN 모델 가중치를 저장하고 보상 값을 출력한다.
4. 훈련 프로세스 동안의 결과를 기록한다고 말했다. 보상과 모델 성능에 대한 다양한 지표를 저장하기 위해 다양한 지표가 속성으로 포함된 훈련 메타데이터 클래스를 정의해야 한다.	4. 훈련 프로세스 동안의 결과를 기록한다고 언급했는데, 보상과 모델 성능에 대한 다양한 지표를 저장하기 위해 다양한 지표가 속성으로 포함된 훈련 메타데이터 클래스를 정의해야 한다.
웹 브라우저인 Firefox의 새로운 버전인 57에서 러스트로 개발해 실행 속도를 2배 빠르게 해 사람들을 놀라게 했다. 그 때 까지 브라우저 개발과 같은 시스템과 관련된 개발은 C/C++을 이용하는 것이 일반적이었다. 하지만 브라우저 개발에 C/C++ 외의 프로그래밍 언어인 '러스트'가 대대적으로 사용된 것이다. 게다가 실행 속도 향상에도 큰 기여를 했기 때문에 러스트는 큰 주목을 끌게 됐다.	웹 브라우저인 파이어폭스의 새로운 버전인 57에서 러스트로 개발해 실행 속도를 2배 빠르게 해 사람들을 놀라게 했다. 그때까지 브라우저 개발과 같은 시스템과 관련된 개발에는 C/C++를 이용하는 것이 일반적이었다. 하지만 브라우저 개발에 C/C++ 외의 프로그래밍 언어인 '러스트'가 대대적으로 사용된 것이다. 게다가 실행 속도 향상에도 크게 기여했기 때문에 러스트는 큰 주목을 끌게 됐다.
이 책을 집필할 시점, 러스트의 점유율은 낮았지만 많은 코어 이용자가에게 사랑받고 있다. 이처럼 두터운 지지를 받고 있는 러스트는 가까운 미래에 보급률이 크게 늘어날 것이라 생각한다.	이 책을 집필하는 시점에 러스트의 점유율은 낮지만 많은 코어 이용자에게 사랑받고 있다. 이처럼 두터운 지지를 받고 있는 러스트는 가까운 미래에 보급이 크게 늘어날 것이라 생각한다.
파이썬을 비롯해 많은 언어에서 이용하고 있는 GC라는 메모리 관리 메커니즘은 메모리 관리에 드는 수고를 대폭 줄여준다. 하지만 GC에도 단점은 있다. 바로 실행 시 오버헤드(Overhead - 어떤 처리를 하기 위해 소요되는 간접적인 자원)가 크다는 점이다.	파이썬을 비롯해 많은 언어에서 이용하고 있는 GC라는 메모리 관리 메커니즘은 메모리 관리에 드는 수고를 많이 줄여준다. 하지만 GC에도 단점은 있다. 바로 실행 시 오버헤드(Overhead - 어떤 처리를 하는 데 소요되는 간접적인 자원)가 크다는 점이다.
가령 어느 프로그램 내에서 상품의 할인율을 0.7로 지정하고, 할인율 0.7을 전제로 나머지 부분을 구현했을 때 이 할인율이 도중에 변경된다면 계산 결과가 제대로 나오지 않게 된다. 이런 경우 할인율을 상수로 선언하면 도중에 값이 바뀌지 않기 때문에 계산과 관련된 버그가 발생하지 않는다. 러스트에서라면 불변 변수의 값 변경을 시도하기 때문에 컴파일을 할 때 에러가 발생해 문제가 되는 부분을 바로 찾을 수 있다.	가령 어느 프로그램에서 상품의 할인율을 0.7로 지정하고, 할인율 0.7을 전제로 나머지 부분을 구현했을 때 이 할인율이 도중에 변경된다면 계산 결과가 제대로 나오지 않는다. 이런 경우 할인율을 상수로 선언하면 도중에 값이 바뀌지 않으므로 계산과 관련된 버그가 생기지 않는다. 러스트에서라면 불변 변수의 값 변경을 시도하기 때문에 컴파일을 할 때 에러가 발생해 문제가 되는 부분을 바로 찾을 수 있다.
이 책은 웹에 관해서 다룹니다. 한 단어로 웹이라 말하지만, 사실 그 의미는 다양합니다. 많은 사람들이 웹이라는 말을 듣는다면, 브라우저를 통해 사용하는 Google이나 Naver 등을 떠올릴 지도 모릅니다. 분명히 HTML, CSS, JavaScript 같은 언어로 작성된 페이지들은 웹에서 제공되는 기본적인 서비스이기는 합니다. 한편, 스마트폰이나 IoT 등 인터넷을 통해 접속하는 서비스가 늘어남에 따라 웹이 담당하는 역할 또한 계속해서 확대되고 있습니다. 여러분이 매일 사용하는 스마트폰 애플리케이션도 웹의 연장선에 있는 기술이며, 최근 화제가 되고 있는 빅 데이터라 불리는 데이터의 대부분이 웹을 통해 수집된 데이터입니다.	이 책은 웹에 관해서 다룹니다. 한 단어로 웹이라 말하지만, 사실 그 의미는 다양합니다. 많은 사람들이 웹이라는 말을 듣는다면, 브라우저를 통해 사용하는 구글이나 네이버를 떠올릴지도 모릅니다. 분명히 HTML, CSS, 자바스크립트 같은 언어로 작성된 페이지들은 웹에서 제공되는 기본적인 서비스이기는 합니다. 한편, 스마트폰이나 사물 인터넷(IoT) 등 인터넷을 통해 접속하는 서비스가 늘어남에 따라 웹이 담당하는 역할 또한 계속해서 확대되고 있습니다. 여러분이 매일 사용하는 스마트폰 애플리케이션도 웹의 연장선에 있는 기술이며, '빅데이터'의 대부분이 웹을 통해 수집된 데이터입니다.
또한 이 책에서는 한 페이지에 하나의 주제를 다룹니다. 그 한 페이지의 주제를 문장과 그림을 사용해 설명합니다. 개념적인 부분은 문장 뿐만 아니라 그림을 함께 보면 쉽게 이미지를 그릴 수 있을 것입니다.	또한 이 책에서는 한 페이지에 하나의 주제를 다룹니다. 그 한 페이지의 주제를 문장과 그림으로 설명합니다. 개념적인 부분은 문장뿐만 아니라 그림을 함께 보면 쉽게 이미지를 그릴 수 있을 것입니다.
예를 들어, 웹 메일은 하이퍼텍스트를 사용해 메일 목록 화면이나 편집 화면 등을 표시함으로써, 사용자가 메일 서버 안의 메일을 표시하거나 조작할 수 있도록 하는 가교 역할을 합니다. 구체적으로는 하이퍼텍스트로 작성된 메일을 조작하는 화면에서 사용자가 수행한 조작을, 웹 서버가 사용자 대신 메일 서버에 전달하고 실제 메일에 대한 조작을 수행합니다.	예를 들어, 웹 메일은 하이퍼텍스트를 사용해 메일 목록 화면이나 편집 화면 등을 표시함으로써, 사용자가 메일 서버 안의 메일을 표시하거나 조작할 수 있게 해줍니다. 구체적으로는 하이퍼텍스트로 작성된 메일을 조작하는 화면에서 사용자가 수행한 조작을, 웹서버가 사용자 대신 메일 서버에 전달하고 실제 메일에 대한 조작을 수행합니다.
**웹 서버**는 웹 브라우저에서 콘텐츠 요청이 있을 때, 필요한 콘텐츠를 네트워크를 통해 웹 브라우저로 송신하는 역할을 담당합니다. 콘텐츠는 웹 서버를 통해 송신되기 때문에 웹 페이지라고 불립니다.	**웹서버**는 웹브라우저에서 콘텐츠 요청이 있을 때, 필요한 콘텐츠를 네트워크를 통해 웹브라우저로 송신합니다. 콘텐츠는 웹서버를 통해 송신되므로 '웹페이지'라고 불립니다.
데이터 전송 처리 등은 애플리케이션 계층 보다 하위의 계층에서 담당합니다.	데이터 전송 처리 등은 애플리케이션 계층보다 하위의 계층에서 담당합니다.
위 내용은 HTTP에 정의되어 있는 헤더 필드의 일부입니다. 헤더 필드는 독자적으로 정의한 것도 사용할 수 있습니다.	위 내용은 HTTP에 정의된 헤더 필드의 일부입니다. 헤더 필드는 독자적으로 정의한 것도 사용할 수 있습니다.
HTTPS를 사용함으로써 '도청', '조작', '위장'이라는 웹 사이트를 열람할 때의 위험성을 방지할 수 있습니다. 웹 브라우저와 웹 서버에서 갑자기 HTTPS 통신이 시작하는 것은 아닙니다. HTTPS에서의 통신을 시작하는 데는 크게 나누어 다음 네 단계로 통신을 수행해야 합니다.	웹사이트를 열람할 때 HTTPS를 사용함으로써 '도청', '변조', '위장' 등의 위험성을 방지할 수 있습니다. 웹브라우저와 웹서버에서 갑자기 HTTPS 통신이 시작하는 것은 아닙니다. HTTPS에서의 통신을 시작하는 데는 크게 나누어 다음 네 단계로 통신을 수행해야 합니다.
하지만 웹의 진화와 함께 HTTP가 스테이트리스 구조로는 곤란한 상황이 늘어났습니다. 예를 들어, 쇼핑 사이트에서의 '제품을 선택한다', '제품을 장바구니에 넣는다', '장바구니 내용을 확인한다', '제품을 구입한다;' 같은 동작은 웹 서버에서 보면 웹 브라우저로부터의 다른 동작(HTTP 요청)이 됩니다. 그렇기 때문에 제품을 장바구니에 넣은 동작을 하더라도 '제품을 장바구니에 넣었다'는 상태가 웹 서버에는 저장되지 않으므로, 다음 동작에서 장바구니의 내용을 확인해도 장바구니에 제품이 들어있지 않게 됩니다.	하지만 웹의 진화와 함께 HTTP가 스테이트리스 구조로는 곤란한 상황이 늘어났습니다. 예를 들어, 쇼핑 사이트에서의 '제품을 선택한다', '제품을 장바구니에 넣는다', '장바구니 내용을 확인한다', '제품을 구입한다' 같은 작동은 웹서버에서 보면 웹브라우저로부터의 다른 작동(HTTP 요청)이 됩니다. 그렇기 때문에 제품을 장바구니에 넣은 작동을 하더라도 '제품을 장바구니에 넣었다'는 상태가 웹서버에는 저장되지 않으므로, 다음 작동에서 장바구니의 내용을 확인해도 장바구니에 제품이 들어있지 않게 됩니다.
하지만 Cookie를 사용하는 방법에 비해 정보가 누출될 가능성이 높기 때문에, 잘 사용하지는 않습니다.	하지만 쿠키를 사용하는 방법에 비해 정보가 누출될 가능성이 높아서 잘 쓰이지 않습니다.
이미 잠재적인 개선 사항으로 게이트웨이를 도입했다. 게이트웨이를 중심점으로 도입할 경우 모든 웹 서버를 강력하게 연결하지 않도록 해야 한다. 따라서 전용 레지스트리 서비스 또는 다른 검색 매커니즘을 통한 일부 느슨한 결합을 강력히 권장한다.	이미 개선점으로 게이트웨이를 도입했다. 게이트웨이를 중심점으로 도입할 경우 모든 웹서버가 게이트웨이에 강력하게 결합되지 않도록 해야 한다. 따라서 전용 레지스트리 서비스 또는 다른 검색 메커니즘을 통한 일부 느슨한 결합이 필요하다.
주요 이슈들 또한 이러한 장점과 함께 상속된다. 예를 들어서 프론트엔드는 일반적인 UX 패턴을 사용하여 일관성을 유지해야 하기 때문에 마이크로 서비스에 가까이 접근하기가 매우 어렵다. 이는 정의에 따라 반드시 일치하는 것이 아니다. 마찬가지로 간단한 접근 방식도 상당히 빠르게 한계에 부딪힐 것이다.	그러나 단점들 또한 이 장점으로부터 비롯된다. 예를 들어 프런트엔드는 일반적인 UX 패턴을 사용하여 일관성을 유지해야 하기 때문에 마이크로서비스와 양립하기 어렵다. 정의에 비추어봐도 마이크로서비스는 일관성과 거리가 멀기 때문이다. 따라서 웹 접근 방식은 상당히 빠르게 한계에 부딪힐 것이다.
그렇다면 웹 접근 방식은 언제 사용해야 할까? 일관성이 필요하지 않을 때는 웹 접근 방식이 타당하다. 또한 제3자 출처의 요소를 포함해야 하거나 제 3자 대상에 요소를 제공해야 하는 경우도 사용될 수 있다. 따라서 타사 쿠키 동의서 솔루션, 채팅 봇 또는 유사한 서비스를 사용하는 대부분의 웹 사이트는 이미 마이크로 프론트엔드를 활용하고 있다.	그렇다면 웹 접근 방식은 언제 사용해야 할까? 일관성이 필요하지 않을 때는 웹 접근 방식이 적절하다. 예를 들어 마이크로 프런트엔드의 일부분을 서드 파티의 소스로 포함하거나 타깃으로 제공할 수 있다. 따라서 서드 파티 쿠키 동의 솔루션, 채팅 봇 또는 유사한 서비스를 사용하는 대부분의 웹사이트는 이미 마이크로 프런트엔드를 활용하고 있다.
당연히 대답은 바꿀 수 없다이다. 링크는 항상 소유자에 의해 결정된다. 그러나 우리가 할 수 있는 것은 중앙 또는 로컬 링크 디렉토리를 도입하는 것이다. 이러한 연결 디렉토리에 숨겨진 아이디어는 대상 링크가 변경될 수 있지만 이러한 변경은 즉시 발견되고 수정할 수 있다는 것이다. 따라서 이는 일종의 신뢰성 계층으로 작용해야 한다. 다음에는 중앙 및 로컬 링크 디렉토리에 대해 자세히 살펴보자.	그에 대한 대답은 당연히 '바꿀 수 없다'이다. 링크의 정보는 항상 소유자에 의해 정해지기 때문이다. 하지만 중앙 또는 로컬 연결 디렉터리를 도입하는 것이 해결책이 될 수 있다. 이 해결책을 좀 더 살펴보면 참조하는 링크의 정보가 변경될 수 있지만 이러한 변경은 즉시 발견되고 수정이 가능하다. 따라서 이는 일종의 신뢰성을 담당하는 계층이다. 다음에는 중앙 및 로컬 연결 디렉터리에 대해 자세히 살펴보자.
여기서의 질문은 다음과 같다. 이에 대해 어떤 것을 할 수 있을까? 확장성에 대한 제약 없이 모든 것을 가능한 격리, 분리 및 독립된 상태로 유지하려면 어떻게 해야할까? 한 가지 가능한 답은 서버 사이드 구성 패턴에서 찾을 수 있다.	그렇다면 규모 변경성에 대한 제약 없이 모든 것을 가능한 한 격리, 분리하고 독립된 상태로 유지하려면 어떻게 해야 할까? 한 가지 가능한 답은 서버 측 구성(server-side composition) 패턴에서 찾을 수 있다.
이후에 이 패턴의 장점과 단점에 대해 논의한다. 마지막으로 이 패턴의 두 가지 특정 구성 요소를 다룬다. 레이아웃은 무엇이며 이 패턴을 사용하여 실제로 마이크로 프론트엔드 개발하는 방법에 관한 부분이다.	이후 이 패턴의 장단점을 논의한다. 마지막으로 이 패턴의 두 가지 특정 컴포넌트를 다룬다. 레이아웃이 무엇이고 이 패턴을 사용하여 실제로 마이크로 프런트엔드를 개발하는 방법에 관한 부분이다.
앱 셸이 매우 간단하기 때문에 잠재적인 개선 사항이 많이 있을 것이다. 그렇지 않은가? 같이 한 번 살펴보자.	앱 셸이 매우 간단하기 때문에 개선점이 많이 있을 것이다. 과연 그런지 같이 한 번 살펴보자.
이 간단한 예에서는 앱 셸에 기본 HTML 구조, 핵심 스타일 및 스크립트 참조만 있다. 인증, 로깅 또는 오류 처리와 같은 항목은 포함되지 않지만 실행 가능한 추가 항목이 될 수 있다.	간단한 예시로 앱 셸은 기본 HTML 구조, 핵심 스타일 및 스크립트만 참조한다. 인증, 로깅 또는 오류 처리와 같은 항목은 포함되지 않지만 실행 가능한 추가 항목이 있을 수 있다.
웹 컴포넌트 표준 자체는 화려한 추상화보다는 기본에 중점을 둔 널리 구현된 표준이다. 분명히 이것은 변경 사항이 기존 구현을 중단하지 않을 가능성이 높다. 그러나 그것은 또한 다른 프레임워크가 그 위에 배치될 것이며 이러한 프레임워크가 웹 구성 요소를 직접 사용하는 것보다 개발을 위한 더 생산적인 기반일 가능성이 높다는 것을 의미한다.	웹 컴포넌트 표준 자체는 화려한 추상화보다는 기본에 중점을 둔 널리 구현된 표준이다. 그래서 변경 사항이 기존 구현을 엉망으로 만들지 않을 것이다. 그러나 이는 다른 프레임워크가 웹 컴포넌트 위에서 돌아갈 수 있다는 것을 의미한다. 또한 이러한 프레임워크가 웹 컴포넌트를 직접 사용하는 것보다 개발을 위해 더 생산적인 기반 기술이 될 수 있다.
웹 구성 요소가 작동하도록 하는 데 필요한 다양한 스크립트를 느리게 로드하기 위해 중앙 웹 구성 요소 레지스트리를 사용하는 아이디어를 간략하게 소개했다. 이것은 게으르지만 동적이기 때문에 실제로 궁극적인 솔루션이 될 것이다. 그러나 이를 완벽하게 운영하는 것 또한 쉽지 않다.	웹 컴포넌트의 작동에 필요한 다양한 스크립트를 천천히(lazily) 로드하기 위해 중앙 웹 컴포넌트 레지스트리를 사용하는 아이디어를 간략하게 소개했다. 이것은 동적이면서도 지연된 방식이므로 실제로 궁극적인 솔루션이 될 것이다. 그러나 이를 완벽하게 운영하기란 쉽지 않다.
이전의 SPA 구성과 마찬가지로 사용자 상호 작용이 상당히 높다는 것을 보았지만 SPA 구성과 달리 사용자 경험과 개발자 경험은 원활해야 한다. 내부 복잡성과 도구 의존성은 증가했지만 주요 단점은 앱 셸에 정의된 API에 대한 모듈의 종속성이다.	이전의 SPA 구성과 마찬가지로 사용자 상호 작용이 상당히 원활하지만 그에 준하는 사용자 경험과 개발자 경험이 필요하다. 또한 내부 복잡성과 도구 의존성이 증가함에 따라 앱 셸에 정의된 API에 대한 모듈의 의존성 문제가 있다.